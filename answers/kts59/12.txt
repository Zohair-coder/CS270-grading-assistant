(define (run-on-truth-table expression tt)
  (if (null? tt)'() ; base case for empty list
 
      ;spacing for organization

      ; run expression on each item, return true if satified
      ; cons, first on table, then call function on rest of table
      (cons (bool-eval expression (first tt)) (run-on-truth-table expression (rest tt))
      )
      ))



;Tests
(define-test-suite run-on-truth-table-suite
(check-equal? (run-on-truth-table '(NOT a) (make-truth-table '(a)))'(#f #t))
(check-equal? (run-on-truth-table '(OR (NOT a) a) (make-truth-table '(a)))'(#t #t))
(check-equal? (run-on-truth-table '(AND a b) (make-truth-table '(a b)))'(#t #f #f #f)))
(run-tests run-on-truth-table-suite 'verbose)

;Now you have a list with the results all all your tests
;we need to decide if atleast one is true
;Given a list of boolean values, return true if atleast one is true, and Return false otherwise
; note: there is no need to make this function recursive

; Question 13: atleast-one-true
(define (atleast-one-true L)
   (if (null? L) #f ;base case for return false

      ;create help functions to check both #t
      (helper_ori (equal? (first L) '#t)
           (equal? (helper_orlist (rest L)) #t)))
      ;first value in L OR the "rest" of L 
      )

(define (helper_ori a b)
  (if b (if b #t #t)
      (if a (if a #t #t) #f)))

(define (helper_orlist L)
  (foldr helper_ori #f L))

