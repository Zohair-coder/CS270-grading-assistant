(define (get-variables expression)
  (cond
    [(is-constant? expression) null]
    [(is-variable? expression) (list expression)]
    [(is-not? expression) (remove-duplicates (append '() (get-variables (second expression))))]
    [else (remove-duplicates(append (append (get-variables (second expression))) (get-variables (third expression))))])
  )


(define-test-suite get-variables-suite
(check-equal? (get-variables 'a)'(a))
(check-equal? (get-variables '(OR a b)) '(a b))
(check-equal? (get-variables '(AND (OR a (NOT b)) (IMPLIES c (IFF d #t)))) '(a b c d))
(check-equal? (get-variables '(AND (NOT a) a))'(a))
(check-true (or (equal? (get-variables '(AND (OR a b) (AND b a))) '(b a))
  (equal? (get-variables '(AND (OR a b) (AND b a))) '(a b)))))
;note: either (b a) or (a b) is correct, but you will find (b a) is the easier approach.
(run-tests get-variables-suite 'verbose)

#|
 Part 4: make-truth-table

 Given a list of variables give the truth table with all settings of varaibles

 Input: A list of variables
 Output: A list of environments with all possible settings for the variables

This sounds easy, but having the output look right is actually a little difficult
We will make some helper functions to get us there

Variable Bindings
For any variable, it can be either true or false
 Given a variable, we want to create a set of bindings with the possibilities
 ( ( (var_name_1 value_1) ) ( (var_name_1 value_2) ) )
This seems like it has a lot of nested lists, but we will need them all. this is just a helper function.
At the top-most point we return a list of two environments
 (make_bindings 'a) returns a table (i.e. list of environments)
 (environments for a) = ( (environment where a=t) (environment where a=f))
 = ( ((a t)) ((a f)))
 note: there is no need to make this function recursive!
|#

; Question 7: make_bindings
(define (make_bindings name)
  (list (list (list name #t)) (list (list name #f))))

